<?php

/**
 * Copyright 2015 Tom치코 Markacz <tomas@markacz.com>.
 *
 * For the full copyright and license information, please view the file LICENSE.md
 * that was distributed with this source code.
 */

namespace Markatom\Accessor;

use Nette\PhpGenerator\ClassType;
use Nette\PhpGenerator\PhpNamespace;
use ReflectionClass;

/**
 * Accessor generator.
 *
 * @author Tom치코 Markacz <tomas@markacz.com>
 */
class Generator
{

	/** Interface for generated accessors. */
	const ACCESSOR_INTERFACE = Accessor::class;

	/** @var Naming */
	private $naming;

	/**
	 * @param Naming $naming
	 */
	public function __construct(Naming $naming)
	{
	    $this->naming = $naming;
	}

	/**
	 * @param string $className
	 * @return string
	 */
	public function generate($className)
	{
		if (!class_exists($className)) {
			throw new InvalidArgumentException("Unknown class $className. Check for typos in class name and make sure"
				. " that given class is properly loaded.");
		}

		$origin    = new ReflectionClass($className);
		$interface = ClassType::from(self::ACCESSOR_INTERFACE);
		$namespace = new PhpNamespace($this->naming->getNamespace());
		$class     = $namespace->addClass($this->naming->deriveClassName($className));

		$class->addDocument("This class was automatically generated by Markatom/Accessor library.");
		$class->addImplement(self::ACCESSOR_INTERFACE);
		$class->addConst('TARGET', $origin->getName());
		$class->addProperty('writer')->setVisibility('private');
		$class->setMethods($interface->getMethods());

		$class->getMethod('read')->setVisibility('public')->setBody($this->generateReadBody($origin));
		$class->getMethod('write')->setVisibility('public')->setBody($this->generateWriteBody($origin));

		return (string) $namespace;
	}

	/**
	 * @param ReflectionClass $origin
	 * @return string
	 */
	private function generateWriteBody(ReflectionClass $origin)
	{
		$class = $origin->getName();

		$body = "if (!\$this->writer) {\n"
			. "\t\$this->writer = \\Closure::bind(function (\$property, \$value) {\n"
			. "\t\t\$this->\$property = \$value;\n"
			. "\t}, \$object, '$class');\n"
			. "}\n\n";

		foreach ($origin->getProperties() as $property) {
			$name = $property->getName();

			if ($property->isPublic()) {
				$body .= "\$object->$name = \$data['$name'];\n";

			} else {
				$body .= "\$this->writer->__invoke('$name', \$data['$name']);\n";
			}
		}

		return $body;
	}

	/**
	 * @param ReflectionClass $origin
	 * @return string
	 */
	private function generateReadBody(ReflectionClass $origin)
	{
		$class = $origin->getName();

		$body = "\$data = (array) \$object;\n\n"
			. "return [\n";

		foreach ($origin->getProperties() as $property) {
			$name  = $property->getName();

			if ($property->isPrivate()) {
				$key = "\\00$class\\00$name";

			} elseif ($property->isProtected()) {
				$key = "\\00*\\00$name";

			} else {
				$key = $name;
			}

			$body .= "\t'$name' => \$data[\"$key\"],\n";
		}

		return $body . "];\n";
	}

}
